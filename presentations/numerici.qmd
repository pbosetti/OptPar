---
title: "Ottimizzazione dei parametri di un processo manifatturiero"
subtitle: "Metodi numerici"
author: "Paolo Bosetti"
institute: "Università di Trento, Dipartimento di Ingegneria Industriale"
date: 2025-11-03
date-modified: today
date-format: "DD MMMM YYYY"
lang: it
draft: false
categories: [intro, meeting]
format: revealjs
---

```{r setup}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE
)
library(tidyverse)
library(neldermead)
```


## Contenuti

* Simulazione numerica: Analisi/Metodo agli Elementi Finiti (FEA/FEM)
* Ottimizzazione numerica


# Elementi finiti
Ovvero: *Divide et Impera*


## Come funziona il metodo

Il metodo FEM:

* Suddivide il dominio in studio in elementi più piccoli
* Ogni elemento dispone di una **funzione di forma**
* La funzione di forma approssima il comportamento della **fisica** in esame
* Ad esempio, in caso elastico la funzione di forma rappresenta la relazione tra forza e spostamento
* Le funzioni di forma forniscono una relazione matriciale tra il vettore dei gradi di libertà (DoF) $u_n$ e il vettore dei carichi $f_n$, tramite la matrice di rigidezza locale $\mathbf{k}_e$:
$$
f_n = \mathbf{k}_e\cdot u_n
$$
* Le matrici locali vengono combinate in una **matrice globale** $\mathbf{K}$, tale che: $f = \mathbf{K}\cdot u$
* L'**inversione della matrice di rigidezza globale** fornisce i DoF $u$ come risultato dei carichi $f$


## Come funziona il metodo --- Esempio

:::columns
:::column
* Consideriamo una trave snella incastrata con carico trasverso $F$ ad una estremità
* Rappresentiamo la trave con due elementi di uguale lunghezza
* Ogni **nodo** $i$ ha due DoF: spostamento verticale $w_i$ e rotazione $\vartheta_i$
:::


:::column
![Trave incastrata, in due elementi](../images/fem_1.png)
:::
:::

:::callout-important
## Approssimazione
Ovviamente la soluzione è approssimata, come si osserva conforntando i segmenti tratteggiati (soluzione FEM) con la deformata reale (curva parabolica spessa)

Tuttavia, è evidente che è sufficiente **infittire la griglia di nodi** (p *mesh*) per ridurre **a piacere** l'errore di approssimazione. Il limite è il costo computazionale.
:::


## Come funziona il metodo --- Esempio

Per un elemento a due nodi, il sistema di **equazioni locali** che collega i DoF con i carichi è $f_n = \mathbf{k}_e\cdot u_n$, dove:

* $f_n = [f_1, m_1, f_2, m_2]$, dove $f_i$ sono le forze e $m_i$ sono i momenti
* $u_n = [w_1, \vartheta_1, u_2, \vartheta_2]$
* $k_e$ è una matrice simmetrica:
$$
\mathbf{k}_e = \frac{EI}{L_e^3}
\begin{bmatrix}
12 & 6L_e & -12 & 6L_e  \\
\cdot & 4L_e^2 & -6L_e & 2L_e^2 \\
\cdot & \cdot & 12 & -6L_e \\
\cdot & \cdot & \cdot & 4L_e^2
\end{bmatrix}
$$

Il passo successivo richiede l'**assemblaggio della matrice di rigidezza globale $K$**


## Come funziona il metodo --- Esempio

* Si mappano gli indici locali in indici globali:
  - elemento 1: $[1, 2, 3, 4]\rightarrow[1, 2, 3, 4] = c^{(1)}$
  - elemento 2: $[1, 2, 3, 4]\rightarrow[3, 4, 5, 6] = c^{(2)}$
* Si compone $\mathbf{K}$ che deve essere una matrice $6\times 6$ (dato che ho 6 indici globali e quindi 6 equazioni)
* Gli indici della matrice globale sono:
$$
\mathbf{K} = \mathbf{I}_{6\times 6} \\
\forall i, j \in \{1, \dots, 4\}, e \in \{1, 2\}:~~~\mathbf{K}_{c^{(e)}_i, c^{(e)}_j} += \mathbf{k}^{(e)}_{i,j}
$$

## Come funziona il metodo --- Esempio

In definitiva:

$$
\begin{bmatrix}
k^{(1)}_{11}  & k^{(1)}_{12}  & k^{(1)}_{13}  & k^{(1)}_{14}  & 0 & 0\\
\cdot  & k^{(1)}_{22}  & k^{(1)}_{13}  & k^{(1)}_{14}  & 0 & 0\\
\cdot & \cdot  & k^{(1)}_{33} +  k^{(2)}_{11} & k^{(1)}_{34} + k^{(2)}_{12}  & 0 & 0\\
\cdot & \cdot & \cdot & k^{(1)}_{14} +k^{(2)}_{22}  & k^{(2)}_{23} & k^{(2)}_{24}\\
\cdot & \cdot & \cdot & \cdot & k^{(2)}_{33} & k^{(2)}_{34}\\
\cdot & \cdot & \cdot & \cdot & \cdot & k^{(2)}_{44}
\end{bmatrix}
\cdot
\begin{bmatrix}
w_1 \\ \vartheta_1 \\
w_2 \\ \vartheta_2 \\
w_3 \\ \vartheta_3 \\
\end{bmatrix} = 
\begin{bmatrix}
F_1 \\ M_1 \\
F_2 \\ M_2 \\
F_3 \\ M_3 \\
\end{bmatrix}
$$

Che va risolta calcolando l'**inversa** $\mathbf{K}^{-1}$, per cui $u = \mathbf{K}^{-1}\cdot f$


## Commenti

* Il metodo è adatto a qualsiasi **fisica** purché siano disponibili relazioni tra [variabili di stato]{.bred} (spostamenti/rotazioni, temperature, velocità, carica elettrica, ...) e [carichi applicati]{.bgreen} (forze/momenti, calore, pressione, campo elettrico, ...)
* Se le condizioni di carico dipendono dallo stato (ad es. grandi spostamenti, deformazione plastica) si produce iterando su passi di applicazione del carico
* Le fisiche possono essere calcolate in parallelo **se non si influenzano**
* Se le fisiche sono **correlate**, si procede in maniera iterativa: si applicano gradualmente i carichi alla fisica A, si calcolano le variabili di stato, si applica gradualmente il carico della fisica B, e si itera. È il caso di problemi **termoelastici**, in cui lo scambio termico dipende dalla deformazione e le proprietùà elastiche dipendono dalla temperatura

:::callout-important
In altre parole, ogni problema la cui relazione carico-stato non sia lineare e/o sia accoppiata con un'altra fisica richiede un approccio iterativo che è computazionalmente oneroso e può non convergere
:::


## Proprietà del mezzo/materiale

Il limite principale dei metodi FEM è la **disponibilità di un modello di materiale calibrato**

* per un modello lineare elastico sono sufficienti il **modulo elastico** $E$ e il **coefficiente di Poisson** $\nu$
* per un processo termo-elastoplastico, che consideri anche la relazione tra proprietà meccaniche, temperatura, velocità di deformazione, incrudimento, e generazione di calore associato alla deformazione plastica, i modelli sono molto meno assodati, sono spesso semi-empirici o empirici, ad es. Johnson-Cook:
$$
\sigma = \left(Y + B\,\varepsilon_p^n\right)\left(1 + C \ln\frac{\dot{\varepsilon}_p}{\dot{\varepsilon}_0}\right)\left(1 - T^m\right)
$$
dove: $Y$ è lo sforzo di snervamento, $B$ è il coefficiente di incrudimento, $n$ è l'esponente di incrudimento, $C$ è la sensibilità alla velocità di deformazione, $m$ è il *thermal softening*

:::aside
Vedi ad es. la [Barra di Hopkinson](https://en.wikipedia.org/wiki/Split-Hopkinson_pressure_bar){target="wiki"} per le prove di deformazione ad altissima velocità (comunque inferiori alle velocità per un processo di taglio)
:::

## Esempi

:::columns
:::column
![](https://ars.els-cdn.com/content/image/1-s2.0-S1526612517300439-gr9.jpg)
:::

:::column
![](https://media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs11831-018-09313-9/MediaObjects/11831_2018_9313_Fig14_HTML.png)

:::callout-note
* Le sole simulazioni richiedono tempi di calcolo di decine di ore
* Ogni modello simulativo deve essere verificato per convergenza (dimensione *mesh*) e **validato**
:::
:::
:::


# Ottimizzazione numerica


## Nelder-Mead

:::columns
:::column
* Si definisce un **simplesso** un iper-poligono con N vertici su una superficie di risposta in uno spazio N-dimensionale
* Il simplesso viene iterativamente trasformato **precipitando** nel minimo locale

![Simplesso in 2-D: possibili trasformazioni](https://upload.wikimedia.org/wikipedia/commons/7/72/An-iteration-of-the-Nelder-Mead-method-over-two-dimensional-space-showing-point-p-min.png){width="80%"}
:::

:::column
![Simplesso Nelder-Mead nella funzione di Rosenbrock](https://upload.wikimedia.org/wikipedia/commons/e/e4/Nelder-Mead_Rosenbrock.gif)
:::
:::


## Traiettoria --- Minimi locali

```{r}
himmelblau <- function(x, y) (x^2+y-11)^2+(x+y^2-7)^2
df <- expand.grid(
  x = seq(-6, 6, length.out=100),
  y = seq(-6, 6, length.out=100)
) %>% 
  mutate(z = himmelblau(x, y))

p <- df %>% 
  ggplot(aes(x=x, y=y, z=sqrt(z))) + 
  geom_contour_filled(bins=20, show.legend = FALSE) + 
  geom_contour(bins=20, show.legend = FALSE, color="black") + 
  scale_fill_viridis_d(option="D", direction=1) + 
  coord_fixed()
```

:::columns
:::column

:::

:::column
```{r}
p
```
:::
:::



## Traiettoria --- Minimi locali

:::callout-note
La **posizione di partenza** del simplesso può determinare il risultato finale, precipitando in minimi differenti
:::

```{r}
optfun <- function(x = NULL,
                   index = NULL,
                   fmsfundata = NULL) {
  return(list(
    f = himmelblau(x[1], x[2]),
    g = c(),
    c = c(),
    gc = c(),
    index = index,
    this = list(costfargument = fmsfundata)
  ))
}
nm <- neldermead()
nm <- neldermead.set(nm, 'numberofvariables', 2)
nm <- neldermead.set(nm, 'function', optfun)
nm <- neldermead.set(nm, 'storehistory', TRUE)

x0 <- transpose(c(4, 4))
nm <- neldermead.set(nm, 'x0', x0)
nm <- neldermead.search(nm)

traj <- tibble(
  step = 1:neldermead.get(nm, "iterations"),
  x = map_dbl(neldermead.get(nm, 'historyxopt'), ~.[1]),
  y = map_dbl(neldermead.get(nm, 'historyxopt'), ~.[2]),
) 

df <- expand.grid(
  x = seq(-6, 6, length.out=300),
  y = seq(-6, 6, length.out=300)
) %>% 
  mutate( z = himmelblau(x, y)) 

breaks <- c(0.1, 1, 5, 10, 50, 100, 500, 1000, 2000, 5000)
p1 <- df %>% 
  ggplot(aes(x=x, y=y)) + 
  geom_contour_filled(aes(z=z), breaks=breaks, show.legend = FALSE) +
  geom_contour(aes(z=z), breaks=breaks) +
  geom_point(data=slice(traj, 1, n()), color="orange", shape=c(15, 16), size=3) +
  geom_path(data=traj, color="red") + 
  coord_equal()
```
```{r}
nm2 <- neldermead()
nm2 <- neldermead.set(nm2, 'numberofvariables', 2)
nm2 <- neldermead.set(nm2, 'function', optfun)
nm2 <- neldermead.set(nm2, 'storehistory', TRUE)

x0 <- transpose(c(-1.2, -1.5))
nm2 <- neldermead.set(nm2, 'x0', x0)
nm2 <- neldermead.search(nm2)

traj <- tibble(
  step = 1:neldermead.get(nm2, "iterations"),
  x = map_dbl(neldermead.get(nm2, 'historyxopt'), ~.[1]),
  y = map_dbl(neldermead.get(nm2, 'historyxopt'), ~.[2]),
) 

p2 <- df %>% 
  ggplot(aes(x=x, y=y)) + 
  geom_contour_filled(aes(z=z), breaks=breaks, show.legend = FALSE) +
  geom_contour(aes(z=z), breaks=breaks) +
  geom_point(data=slice(traj, 1, n()), color="orange", shape=c(15, 16), size=3) +
  geom_path(data=traj, color="red") + 
  coord_equal()
```

:::columns
:::column
```{r}
p1
```
:::

:::column
```{r}
p2
```
:::
:::




# Segue...

[Metodi sperimentali {{< bi arrow-right-square-fill >}}](sperimentali.qmd)