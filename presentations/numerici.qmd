---
title: "Ottimizzazione dei parametri di un processo manifatturiero"
subtitle: "Metodi numerici"
author: "Paolo Bosetti"
institute: "Università di Trento, Dipartimento di Ingegneria Industriale"
date: 2025-11-03
date-modified: today
date-format: "DD MMMM YYYY"
lang: it
draft: false
categories: [intro, meeting]
format: revealjs
---

```{r setup}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE
)
library(tidyverse)
library(neldermead)
library(gganimate)
```


## Contenuti {{< bi card-list >}}

* Simulazione numerica: Analisi/Metodo agli Elementi Finiti (FEA/FEM)
* Ottimizzazione numerica


# Elementi finiti
Ovvero: *Divide et Impera*


## Come funziona il metodo

Il metodo FEM:

* Suddivide il dominio in studio in elementi più piccoli
* Ogni elemento dispone di una **funzione di forma**
* La funzione di forma approssima il comportamento della **fisica** in esame
* Ad esempio, in caso elastico la funzione di forma rappresenta la relazione tra forza e spostamento
* Le funzioni di forma forniscono una relazione matriciale tra il vettore dei gradi di libertà (DoF) $u_n$ e il vettore dei carichi $f_n$, tramite la matrice di rigidezza locale $\mathbf{k}_e$:
$$
f_n = \mathbf{k}_e\cdot u_n
$$
* Le matrici locali vengono combinate in una **matrice globale** $\mathbf{K}$, tale che: $f = \mathbf{K}\cdot u$
* L'**inversione della matrice di rigidezza globale** fornisce i DoF $u$ come risultato dei carichi $f$


## Come funziona il metodo --- Esempio

:::columns
:::column
* Consideriamo una trave snella incastrata con carico trasverso $F$ ad una estremità
* Rappresentiamo la trave con due elementi di uguale lunghezza
* Ogni **nodo** $i$ ha due DoF: spostamento verticale $w_i$ e rotazione $\vartheta_i$
:::


:::column
![Trave incastrata, in due elementi](../images/fem_1.png)
:::
:::

:::callout-important
## Approssimazione
Ovviamente la soluzione è approssimata, come si osserva conforntando i segmenti tratteggiati (soluzione FEM) con la deformata reale (curva parabolica spessa)

Tuttavia, è evidente che è sufficiente **infittire la griglia di nodi** (p *mesh*) per ridurre **a piacere** l'errore di approssimazione. Il limite è il costo computazionale.
:::


## Come funziona il metodo --- Esempio

Per un elemento a due nodi, il sistema di **equazioni locali** che collega i DoF con i carichi è $f_n = \mathbf{k}_e\cdot u_n$, dove:

* $f_n = [f_1, m_1, f_2, m_2]$, dove $f_i$ sono le forze e $m_i$ sono i momenti
* $u_n = [w_1, \vartheta_1, u_2, \vartheta_2]$
* $k_e$ è una matrice simmetrica:
$$
\mathbf{k}_e = \frac{EI}{L_e^3}
\begin{bmatrix}
12 & 6L_e & -12 & 6L_e  \\
\cdot & 4L_e^2 & -6L_e & 2L_e^2 \\
\cdot & \cdot & 12 & -6L_e \\
\cdot & \cdot & \cdot & 4L_e^2
\end{bmatrix}
$$

Il passo successivo richiede l'**assemblaggio della matrice di rigidezza globale $K$**


## Come funziona il metodo --- Esempio

* Si mappano gli indici locali in indici globali:
  - elemento 1: $[1, 2, 3, 4]\rightarrow[1, 2, 3, 4] = c^{(1)}$
  - elemento 2: $[1, 2, 3, 4]\rightarrow[3, 4, 5, 6] = c^{(2)}$
* Si compone $\mathbf{K}$ che deve essere una matrice $6\times 6$ (dato che ho 6 indici globali e quindi 6 equazioni)
* Gli indici della matrice globale sono:
$$
\mathbf{K} = \mathbf{I}_{6\times 6} \\
\forall i, j \in \{1, \dots, 4\}, e \in \{1, 2\}:~~~\mathbf{K}_{c^{(e)}_i, c^{(e)}_j} += \mathbf{k}^{(e)}_{i,j}
$$

## Come funziona il metodo --- Esempio

In definitiva:

$$
\begin{bmatrix}
k^{(1)}_{11}  & k^{(1)}_{12}  & k^{(1)}_{13}  & k^{(1)}_{14}  & 0 & 0\\
\cdot  & k^{(1)}_{22}  & k^{(1)}_{13}  & k^{(1)}_{14}  & 0 & 0\\
\cdot & \cdot  & k^{(1)}_{33} +  k^{(2)}_{11} & k^{(1)}_{34} + k^{(2)}_{12}  & 0 & 0\\
\cdot & \cdot & \cdot & k^{(1)}_{14} +k^{(2)}_{22}  & k^{(2)}_{23} & k^{(2)}_{24}\\
\cdot & \cdot & \cdot & \cdot & k^{(2)}_{33} & k^{(2)}_{34}\\
\cdot & \cdot & \cdot & \cdot & \cdot & k^{(2)}_{44}
\end{bmatrix}
\cdot
\begin{bmatrix}
w_1 \\ \vartheta_1 \\
w_2 \\ \vartheta_2 \\
w_3 \\ \vartheta_3 \\
\end{bmatrix} = 
\begin{bmatrix}
F_1 \\ M_1 \\
F_2 \\ M_2 \\
F_3 \\ M_3 \\
\end{bmatrix}
$$

Che va risolta calcolando l'**inversa** $\mathbf{K}^{-1}$, per cui $u = \mathbf{K}^{-1}\cdot f$


## Commenti

* Il metodo è adatto a qualsiasi **fisica** purché siano disponibili relazioni tra [variabili di stato]{.bred} (spostamenti/rotazioni, temperature, velocità, carica elettrica, ...) e [carichi applicati]{.bgreen} (forze/momenti, calore, pressione, campo elettrico, ...)
* Se le condizioni di carico dipendono dallo stato (ad es. grandi spostamenti, deformazione plastica) si produce iterando su passi di applicazione del carico
* Le fisiche possono essere calcolate in parallelo **se non si influenzano**
* Se le fisiche sono **correlate**, si procede in maniera iterativa: si applicano gradualmente i carichi alla fisica A, si calcolano le variabili di stato, si applica gradualmente il carico della fisica B, e si itera. È il caso di problemi **termoelastici**, in cui lo scambio termico dipende dalla deformazione e le proprietùà elastiche dipendono dalla temperatura

:::callout-important
In altre parole, ogni problema la cui relazione carico-stato non sia lineare e/o sia accoppiata con un'altra fisica richiede un approccio iterativo che è computazionalmente oneroso e può non convergere
:::


## Proprietà del mezzo/materiale

Il limite principale dei metodi FEM è la **disponibilità di un modello di materiale calibrato**

* per un modello lineare elastico sono sufficienti il **modulo elastico** $E$ e il **coefficiente di Poisson** $\nu$
* per un processo termo-elastoplastico, che consideri anche la relazione tra proprietà meccaniche, temperatura, velocità di deformazione, incrudimento, e generazione di calore associato alla deformazione plastica, i modelli sono molto meno assodati, sono spesso semi-empirici o empirici, ad es. Johnson-Cook:
$$
\sigma = \left(Y + B\,\varepsilon_p^n\right)\left(1 + C \ln\frac{\dot{\varepsilon}_p}{\dot{\varepsilon}_0}\right)\left(1 - T^m\right)
$$
dove: $Y$ è lo sforzo di snervamento, $B$ è il coefficiente di incrudimento, $n$ è l'esponente di incrudimento, $C$ è la sensibilità alla velocità di deformazione, $m$ è il *thermal softening*

:::aside
Vedi ad es. la [Barra di Hopkinson](https://en.wikipedia.org/wiki/Split-Hopkinson_pressure_bar){target="wiki"} per le prove di deformazione ad altissima velocità (comunque inferiori alle velocità per un processo di taglio)
:::

## Esempi

:::columns
:::column
![](https://ars.els-cdn.com/content/image/1-s2.0-S1526612517300439-gr9.jpg)
:::

:::column
![](https://media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs11831-018-09313-9/MediaObjects/11831_2018_9313_Fig14_HTML.png)

:::callout-note
* Le sole simulazioni richiedono tempi di calcolo di decine di ore
* Ogni modello simulativo deve essere verificato per convergenza (dimensione *mesh*) e **validato**
:::
:::
:::


# Ottimizzazione numerica

## Cosa significa

:::columns
:::column
Se la funzione/campo da ottimizzare è **analitica**, è possibile usare:

* metodi analitici, quando è possibile calcolare gli zeri della derivata
* metodi numerici derivativi, altrimenti

:::

:::column
```{r}
tibble(
  x = seq(0, 12, length.out=100),
  y = 10 - 10*x + x^2,
  y1 = -10 + 2*x
) %>% 
  ggplot(aes(x=x)) + 
  geom_line(aes(y=y)) +
  geom_line(aes(y=y1), color="red") + 
  geom_hline(yintercept = 0, linetype=2) +
  geom_vline(xintercept = 5, linetype=2) 
```
:::
:::

## Cosa significa

:::columns
:::column
Se la funzione/campo da ottimizzare è **analitica**, è possibile usare:

* metodi analitici, quando è possibile calcolare gli zeri della derivata
* metodi numerici derivativi, altrimenti

:::

:::column
![Metodo di Newton-Raphson per gli zeri](https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif)
:::
:::

## Newton-Raphson per minimizzazione

```{r}
#| fig-width: 8
#| fig-height: 4
f  <- function(x) x^4 - 4*x^2 + x + 20
df <- function(x) 4*x^3 - 8*x + 1
ddf <- function(x) 12*x^2 - 8
tgt <- function(x, px, py, b) py - b*px + b * x

# Newton per il minimo: x_{n+1} = x - f'(x)/f''(x)
newton_step <- function(x) x - df(x)/ddf(x)

# Iterazioni
x0 <- 3    # valore iniziale
x_seq <- seq(-2, 3, length.out = 400)
n_iter <- 6


iter <- tibble(
  iter = 1:n_iter,
  x = accumulate(2:n_iter, ~ newton_step(.x), .init = x0),
  y = f(x),
  y1 = df(x),
  y2 = ddf(x)
)

tangents <- tibble(x=x_seq)
for (i in 1:n_iter) {
  v <- iter[i, ]
  tangents[paste0("it.", i)] <- tgt(tangents$x, v$x, v$y1, v$y2)
}

tangents <- tangents %>% 
  pivot_longer(-x, names_to = "iter", values_to = "y") %>% 
  mutate(iter = map_int(iter, ~ str_split(., "\\.")[[1]][2] %>% as.integer()))


# Preparazione dati per il grafico
curve_data <- tibble(
  x = x_seq,
  y = f(x),
  y1 = df(x),
  y2 = ddf(x)
)

curve_data %>% 
  ggplot(aes(x=x)) + 
  geom_hline(yintercept = 0) +
  geom_line(aes(y=y), color="red") +
  geom_line(aes(y=y1), linetype=2) +
  geom_point(data=iter, aes(y=y), color="red") +
  geom_point(data=iter, aes(y=y1)) +
  geom_line(data=tangents, aes(x=x, y=y), linetype=3) +
  scale_color_viridis_c() + 
  facet_wrap(~iter, labeller = \(x) map(x, ~ paste("Iteration", .))) +
  lims(y=c(-10, 90))
```


## E se il campo da ottimizzare non è analitico?

```{r}
himmelblau <- function(x, y) (x^2+y-11)^2+(x+y^2-7)^2
df <- expand.grid(
  x = seq(-6, 6, length.out=100),
  y = seq(-6, 6, length.out=100)
) %>% 
  mutate(z = himmelblau(x, y))

p <- df %>% 
  ggplot(aes(x=x, y=y, z=sqrt(z))) + 
  geom_contour_filled(bins=20, show.legend = FALSE) + 
  geom_contour(bins=20, show.legend = FALSE, color="black") + 
  scale_fill_viridis_d(option="D", direction=1) + 
  coord_fixed()
```

:::columns
:::column
Per quanto visto precedentemente, in casi di applicazione industriale raramente si dispone di un modello analitico, ancor più raramente esso è differenziabile

Servono quindi **metodi numerici *gradient-less***, cioè che non richiedono la conoscenza del gradiente per raggiungere il minimo

Spesso, comunque, il minimo può essere locale e non si ha modo di verificarne l'unicità
:::

:::column
```{r}
p
```
:::
:::

## Nelder-Mead

:::columns
:::column
* Si definisce un **simplesso** un iper-poligono con N vertici su una superficie di risposta in uno spazio N-dimensionale
* Il simplesso viene iterativamente trasformato **precipitando** nel minimo locale

![Simplesso in 2-D: possibili trasformazioni](https://upload.wikimedia.org/wikipedia/commons/7/72/An-iteration-of-the-Nelder-Mead-method-over-two-dimensional-space-showing-point-p-min.png){width="80%"}
:::

:::column
![Simplesso Nelder-Mead nella funzione di Rosenbrock](https://upload.wikimedia.org/wikipedia/commons/e/e4/Nelder-Mead_Rosenbrock.gif)
:::
:::






## Traiettoria --- Minimi locali

:::callout-note
La **posizione di partenza** del simplesso può determinare il risultato finale, precipitando in minimi differenti
:::

```{r}
optfun <- function(x = NULL,
                   index = NULL,
                   fmsfundata = NULL) {
  return(list(
    f = himmelblau(x[1], x[2]),
    g = c(),
    c = c(),
    gc = c(),
    index = index,
    this = list(costfargument = fmsfundata)
  ))
}
nm <- neldermead()
nm <- neldermead.set(nm, 'numberofvariables', 2)
nm <- neldermead.set(nm, 'function', optfun)
nm <- neldermead.set(nm, 'storehistory', TRUE)

x0 <- transpose(c(4, 4))
nm <- neldermead.set(nm, 'x0', x0)
nm <- neldermead.search(nm)

traj <- tibble(
  step = 1:neldermead.get(nm, "iterations"),
  x = map_dbl(neldermead.get(nm, 'historyxopt'), ~.[1]),
  y = map_dbl(neldermead.get(nm, 'historyxopt'), ~.[2]),
) 

df <- expand.grid(
  x = seq(-6, 6, length.out=300),
  y = seq(-6, 6, length.out=300)
) %>% 
  mutate( z = himmelblau(x, y)) 

breaks <- c(0.1, 1, 5, 10, 35, 70, 125, 250, 500, 1000, 2000, 5000)
p1 <- df %>% 
  ggplot(aes(x=x, y=y)) + 
  geom_contour_filled(aes(z=z), breaks=breaks, show.legend = FALSE) +
  geom_contour(aes(z=z), breaks=breaks) +
  geom_point(data=traj, color="red") + 
  geom_point(data=slice(traj, 1, n()), color="orange", shape=c(15, 16), size=3) +
  geom_path(data=traj, color="red") + 
  geom_polygon(
    data=nm$simplex0$x %>% as_tibble(), 
    aes(x=V1, y=V2), 
    fill=NA,
    color="red") + 
  coord_equal()
```

```{r}
nm2 <- neldermead()
nm2 <- neldermead.set(nm2, 'numberofvariables', 2)
nm2 <- neldermead.set(nm2, 'function', optfun)
nm2 <- neldermead.set(nm2, 'storehistory', TRUE)

x0 <- transpose(c(-1.2, -1.5))
nm2 <- neldermead.set(nm2, 'x0', x0)
nm2 <- neldermead.search(nm2)

traj <- tibble(
  step = 1:neldermead.get(nm2, "iterations"),
  x = map_dbl(neldermead.get(nm2, 'historyxopt'), ~.[1]),
  y = map_dbl(neldermead.get(nm2, 'historyxopt'), ~.[2]),
) 

p2 <- df %>% 
  ggplot(aes(x=x, y=y)) + 
  geom_contour_filled(aes(z=z), breaks=breaks, show.legend = FALSE) +
  geom_contour(aes(z=z), breaks=breaks) +
  geom_point(data=traj, color="red") + 
  geom_point(data=slice(traj, 1, n()), color="orange", shape=c(15, 16), size=3) +
  geom_path(data=traj, color="red") + 
  geom_polygon(
    data=nm2$historysimplex[[1]]$x %>% as_tibble(), 
    aes(x=V1, y=V2), 
    fill=NA,
    color="red") + 
  coord_equal()
```

:::columns
:::column
```{r}
p1 
```
:::

:::column
```{r}
p2
```
:::
:::


# Particle swarm

:::columns
:::column
Se il processo/fenomeno può mostrare molti **minimi locali** esistono metodi globali (più costosi). Un esempio è lo sciame di particelle

* si inizializza una griglia di particelle in un dominio
* ogni particella ha un vettore velocità inizialmente convergente al centro
* ad ogni passo si valuta la funzione e si corregge la velocità in proporzione alla riduzione della funzione
* si definisce un **criterio di convergenza**

:::

:::column
![Metodo Particle swarm in 2-D](https://upload.wikimedia.org/wikipedia/commons/e/ec/ParticleSwarmArrowsAnimation.gif)
:::
:::

:::callout-note
Il metodo può essere combinato con altri metodi a ricerca locale (es. Nelder-Mead)
:::


## Cosa ottimizziamo?

Cioè, cosa rappresenta la **funzione da minimizzare**?

* È una **mappa** $\mathbb{R}^n\rightarrow \mathbb{R}$ che identifica un generico **indice di prestazione** (uno scalare) a partire da una combinazione di parametri (un vettore). Può essere (in ordine crescente di costo):
   - una funzione matematica, anche non analitica (con basi fisiche oppure empiriche)
   - il risultato di un algoritmo computazionale, ad es. la valutazione di una variabile di stato in un modello FEM parametrico
   - una misura effettuata su un processo fisico, reale o in scala

:::callout-warning
## Ma purtroppo...
I processi produttivi spesso sono così complessi che la strada più costosa è anche l'unica percorribile
:::


## Nei processi produttivi

Il modello del processo è in generale disponibile **solo in forma numerica**

* si definisce un modello numerico **parametrico**:
  - ua simulazione FEA di dettaglio, in cui alcuni parametri geometrici o proprietà del materiale sono **parametri**
  - un modello per il tempo di processo in funzione di parametri di taglio (es. mediante simulazione su CNC o su CAM)
* Ad es. mediante NM: si definisce un simplesso iniziale: per ogni **vertice** si calcola la **risposta** valutando il modello simulativo, a cui segue la discesa del gradiente verso il minimo

:::callout-important
L'ipotesi sottostante è che il modello computazionale sia disponibile e **validato**
:::



# Segue...

[Metodi sperimentali {{< bi arrow-right-square-fill >}}](sperimentali.qmd)